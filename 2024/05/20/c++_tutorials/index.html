<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++笔记 | 我亦博客</title><meta name="author" content="Gachi51"><meta name="copyright" content="Gachi51"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="C++笔记(尚未整理完毕)小建议如果你拥有C语言程序设计基础，理解以下内容会更加容易。如果你在阅读过程中遇到了不理解的概念请自行上网搜索或查阅相关专业书籍，还是不懂的话可以记下来然后先行跳过。因为计算机知识体系庞大，光有编程语言的基础是远远不够的，所以需要循序渐进地学习，但不用紧张，因为目前我们还不需要很深的知识，需要的是思考、动手和耐心。如果你是非英语母语者且英语词汇量比较匮乏的话，建议你在后面">
<meta property="og:type" content="article">
<meta property="og:title" content="C++笔记">
<meta property="og:url" content="http://weblog51.top/2024/05/20/c++_tutorials/index.html">
<meta property="og:site_name" content="我亦博客">
<meta property="og:description" content="C++笔记(尚未整理完毕)小建议如果你拥有C语言程序设计基础，理解以下内容会更加容易。如果你在阅读过程中遇到了不理解的概念请自行上网搜索或查阅相关专业书籍，还是不懂的话可以记下来然后先行跳过。因为计算机知识体系庞大，光有编程语言的基础是远远不够的，所以需要循序渐进地学习，但不用紧张，因为目前我们还不需要很深的知识，需要的是思考、动手和耐心。如果你是非英语母语者且英语词汇量比较匮乏的话，建议你在后面">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://weblog51.top/img/weblog51.png">
<meta property="article:published_time" content="2024-05-20T09:33:32.000Z">
<meta property="article:modified_time" content="2024-05-21T16:01:49.061Z">
<meta property="article:author" content="Gachi51">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://weblog51.top/img/weblog51.png"><link rel="shortcut icon" href="/img/weblog51.png"><link rel="canonical" href="http://weblog51.top/2024/05/20/c++_tutorials/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-22 00:01:49'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/weblog51.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="我亦博客"><span class="site-name">我亦博客</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-20T09:33:32.000Z" title="发表于 2024-05-20 17:33:32">2024-05-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-21T16:01:49.061Z" title="更新于 2024-05-22 00:01:49">2024-05-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>49分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="C-笔记-尚未整理完毕"><a href="#C-笔记-尚未整理完毕" class="headerlink" title="C++笔记(尚未整理完毕)"></a>C++笔记(尚未整理完毕)</h2><h3 id="小建议"><a href="#小建议" class="headerlink" title="小建议"></a>小建议</h3><p>如果你拥有C语言程序设计基础，理解以下内容会更加容易。<br><br>如果你在阅读过程中遇到了不理解的概念请自行上网搜索或查阅相关专业书籍，还是不懂的话可以记下来然后先行跳过。因为计算机知识体系庞大，光有编程语言的基础是远远不够的，所以需要循序渐进地学习，但不用紧张，因为目前我们还不需要很深的知识，需要的是思考、动手和耐心。<br><br>如果你是非英语母语者且英语词汇量比较匮乏的话，建议你在后面编程的过程中，尽可能去留意这些英文缩写，使用合法的英文和数字等组合命名 <code>函数(Function)</code> 和 <code>变量(Variable)</code> 。平时可以上谷歌去熟悉全英文环境，可以去啃一些英文 <code>markdown</code> 文档（如果时间允许的话），让自己逐渐熟悉全英文环境，这对于后期的学习很有帮助。<br>本篇文章就是使用markdown语法编写的，文件后缀名是 <code>.md</code> 。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>计算机编程语言包括 <code>机器语言</code> 、<code>汇编语言</code> 和 <code>高级语言</code> 。机器语言使用二进制 <code>0</code> 和 <code>1</code> ，通过向计算机 <code>终端(Terminal)</code> 输入二进制数来使计算机执行各种指令，但这种语言对于人来说不易读、不易维护且耗时长，于是便逐渐发展出了汇编语言，在此基础上又进一步发展出了高级语言。<br>高级语言通过 <code>编译器</code> 转换成汇编语言，汇编语言通过 <code>汇编器</code> 转换成机器语言并最终使计算机运行 <code>程序(Program)</code> 。这种上一个程序的输出是下一个的输入的程序组合也称为 <code>工具链</code> 。<br>与 <code>面向过程</code> 的C语言不同，C++是由C语言发展而来的一门 <code>面向对象</code> 的高级语言，类似于C#, Java, Go, Rust 等等。<br>另外，除了以上提到的 <code>编译型语言</code> ，随着时代发展，又出现了 <code>解释器</code> 。解释器使程序直接读取程序并将其转化为中间形态后直接执行。这种 <code>解释型程序(脚本)</code> 与 <code>编译程序</code> 只需编译一次之后计算机就能直接执行编译好的机器指令不同，像是Python、PHP、Ruby、Perl等等语言每次执行都需要经历这个过程，因而程序运行比较慢，这种语言叫做 <code>解释性语言(脚本语言)</code> 。<br>虽然这类语言因为这种特性受到诸多限制而被一些程序员所诟病，但我们也应该清楚工具是为人服务的，不存在着一种完美的工具，我们应该做的是根据自己的实际需求和项目具体情况来选择工具以便高效地完成我们的工作。</p>
<h3 id="准备工作-针对Windows系统"><a href="#准备工作-针对Windows系统" class="headerlink" title="准备工作 | 针对Windows系统"></a>准备工作 | 针对Windows系统</h3><h4 id="设备"><a href="#设备" class="headerlink" title="设备:"></a>设备:</h4><ul style =list-style: disc>
<li>

<p>一台电脑(PC)</p>
</li>
</ul>

<h4 id="开发环境-IDE"><a href="#开发环境-IDE" class="headerlink" title="开发环境(IDE):"></a>开发环境(IDE):</h4><p>下载 社区版 | <a target="_blank" rel="noopener" href="https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Community">Microsoft Visual Studio</a><br>到你喜欢的位置，最好在C盘以外的位置新建一个文件夹并命名，因为C盘存储空间不足会影响系统性能，确保你有足够的空间来下载和安装开发环境。注意命名文件夹时尽量不要出现空格，尽量使用英文大小写加数字或者分隔符 <code>_</code> 的命名方式。</p>
<p>系统兼容性 | 需要注意你的系统版本是否支持，查看 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/visualstudio/releases/2022/system-requirements">系统要求</a></p>
<ul>
<li>

<p>我们当然也可以使用记事本来编写代码，但是也要记得记事本生成的是文件后缀为 <code>.txt</code> 的文本文件，计算机是不能直接读懂的，想要计算机运行需要将其编译为可识别指令。</p>
<li>

<p>集成开发环境 (IDE) 集中了许多有助于你编写和调试代码的开发工具，其中就包括编译器。</p>
<li>

<p>你可能会注意到有相似名称的软件叫 <code>VS code</code> ，但是与集成开发环境不同，它只是代码编辑器。</p>
</li>
</ul>

<h4 id="运行环境-RE"><a href="#运行环境-RE" class="headerlink" title="运行环境(RE):"></a>运行环境(RE):</h4><ul style =list-style: disc>
<li>
安装C++语言运行库
<li>
配置环境变量
</li>
</ul>

<h4 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h4><h4 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h4><h3 id="一、打印输出文本-Hello-World"><a href="#一、打印输出文本-Hello-World" class="headerlink" title="一、打印输出文本 Hello World!"></a>一、打印输出文本 <code>Hello World!</code></h3><p>首先我们先来输入以下代码，然后 <code>Enter</code> 换行，这是预处理阶段的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br></pre></td></tr></table></figure>
<p>当你输入 <code>&lt;</code> ，你会发现VS自动补全了 <code>&gt;</code> ，代码补全功能是这个软件的优势之一<br></p>
<p>接着输入以下代码。int是整型，这里代表该函数的返回类型是整数类型，函数末尾可以返回一个整数(通常是0)，main是主函数，也是我们程序运行的入口。圆括号 <code>()</code> 是该函数的参数列表，如果没有参数可以填void或者不填，花括号 <code>&#123;&#125;</code> 之间的作用域就是给我们用来输入想让计算机输出内容的代码的位置，我们也把花括号之间的区域称为一个 <code>代码块(block)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p style = text-decoration-line:underline><i>注意输入法是英文</i></p>

<p>然后我们来完善主函数代码块，<code>return 0</code> 是一个语句，必须以 <code>;</code> 结尾，用于执行某个操作的指令，在这里的意思是返回一个整数0(习惯上通常代表程序正常终止)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你不慎输错了导致代码排版没对齐，建议你按键盘左上角往下第三个键 <code>Tab</code> 来缩进，大部分格式无误的情况下，VS会自动帮你缩进。<br>我们可以先按 <code>Ctrl+F5</code> 来执行程序</p>
<p>继续完善我们的代码，我们最终要输出语句打印到计算机屏幕上，如果你学过C语言可能会用到诸如 <code>print()</code> 和 <code>printf()</code> 之类的用于格式化输出的函数，在C++里，我们一样可以用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello World!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们可以直接用输出流运算符 <code>&lt;&lt;</code> (重载左移操作符)，使其输出的对象可以是C++内置的数据类型和标准库 <code>std</code> 包含的类的类型。</p>
<p>有更方便我们进行开发的方法，所以我们接着要调用C++标准库 <code>std</code> (standard缩写)的标准输出流对象 <code>cout</code> 。这样输入的数据会先存放到留缓冲区，待缓冲区刷新之后才输出到指定位置，当数据暂存于缓冲区时我们仍有对齐进行修改的方法，这个后面会讲到。这里的 <code>\n</code> 是换行符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello World!\n&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在预处理下面一行输入 <code>using namespace std</code> 代表调用标准命名空间，这样就不用每遇到一个标准库里的对象就要声明一次 <code>std::</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; &quot;!&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><figcaption><span>(endline缩写)和 ```\n``` 一样也有换行的作用，但除此之外还会刷新缓冲区</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">完整代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include <iostream><br>using namespace std<br>int main()<br>{<br>    cout &lt;&lt; “Hello World!” &lt;&lt; endl;<br>    system(“pause”);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">最后 ```ctrl+F5``` 执行程序(暂时不需要用到调试)</span><br><span class="line"></span><br><span class="line">#### 补充</span><br><span class="line">1.输入输出流 ```iostream``` :&lt;br&gt;</span><br><span class="line">也称为 ```I/O流``` ，是C++ 中用于输入和输出数据流的 ```基础类库(BCL)``` ，```io```代表 input 和 output ，是 ```istream类``` 和 ```ostream类``` 两个类名的头字母缩写。```stream``` 代表数据之间的传输操作。&lt;br&gt;iostream 也是由抽象基类 ```ios``` 派生出的 ```istream``` 和 ```ostream``` 通过 ```多重继承``` 而派生出的 ```类``` 。&lt;br&gt;</span><br><span class="line">除此之外，还有用于 ```文件(file)``` 输入和输出的 ```fstream``` 以及用于 ```字符串(string)``` 输入和输出的 ```strstream``` 。</span><br><span class="line"></span><br><span class="line">2.预编译处理器指令 ```#include``` :&lt;br&gt;</span><br><span class="line">预处理器将指示计算机的编译器在实际编译前所需完成的准备工作，这个过程也称为 ```预处理``` 。所有的预处理器指令以 ```#``` 开头，其中最常见的是 ```#include``` ，用于把 ```头文件``` 包含到源文件中。&lt;br&gt;头文件里一般是方法声明，一开始的C语言写的 ```.c``` 文件太长，所以后来就将源文件分开，一部分方法声明放在另一个文件里再写在源文件开头，所以称作头文件，而编译好的既包含外部源文件也包含头文件的二进制文件叫做 ```(静态)库文件``` ，在项目中显示包含的头文件也叫 ```外部依赖``` ，类似于Java里的 ```包(package)``` 。</span><br><span class="line">此外，如果是自定义的头文件则不是用尖括号 ```&lt;&gt;``` 括起来表示，而应该用 ```&quot;&quot;``` 。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include<iostream><br>#include”xxx.h”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以后我们可能还会用到 ```#define``` ，这个预处理指令用于创建符号常量，该符号常量通常称作 ```宏``` ，这个指令也叫做 ```宏定义``` 。简单来说就是给常量取个名字，就像我们称呼圆周率3.1415926535……为π一样，π就是圆周率的名字，建立了这样的对应关系，使得我们可以用字符去替换常量，而且编译器也能读取并转换成相应的常量。</span><br></pre></td></tr></table></figure>
<p>#define PI 3.14</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">要注意宏定义只是简单的字符串代换，是在预处理完成的。</span><br><span class="line"></span><br><span class="line">3.命名空间</span><br><span class="line"></span><br><span class="line">4.&amp;nbsp;```cin``` 和 ```cout``` :&lt;br&gt;</span><br><span class="line">属于上面提及的两个类的对象，分别意为输入和输出，读作 ```c-in``` ，```c-out``` 。As you see, the words mean input and output here. C++ std namespace is a codes library which include &quot;cin&quot; and &quot;cout&quot;, &quot;using namespace std&quot; so that you could use them directly or you must add &quot;std::&quot; on the head of &quot;cin&quot; and &quot;cout&quot;.</span><br><span class="line">&lt;br&gt;</span><br><span class="line">like: </span><br><span class="line">```bash</span><br><span class="line">    cout &lt;&lt; &quot;the string print on the screen.&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; variable;</span><br></pre></td></tr></table></figure>
<p>(这里的大于小于号事实上是箭头，代表数据流流向，不能随意改变)</p>
<p>5.int main(void){return 0;} :<br>Our programs need an entry point where your function is, so you need a function to receive what you input then output on the screen. main function is necessary.</p>
<p>6.system(“pause”) :<br>Use it so that our programs realize that it’s not end and your command window will not close itself automatically.</p>
<p>7.总结 :<br>now you see, when you want to print on the screen, your codes must contain 1 and 2(cout is necessary), the other one you need is a function, but that’s not what we want to talk about now.</p>
<p>Use keyword <code>include</code> to taking the codes in the library(lib),like: <code>#include&lt;lib document&gt;</code><br>常用库(lib)：<br><code>#include&lt;math&gt;</code><br><code>#include&lt;string&gt;</code></p>
<p>8.实操 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">//using namespace std; //此处是单行注释(不会作为编译内容，仅供查看)，分号代表结束一个完整代码语句</span><br><span class="line"></span><br><span class="line">int main()  //定义一个返回值为整型的主函数，无参数列表，相当于(void)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;HELLO WORLD!&quot; &lt;&lt; std::endl; //数据流将&quot;HELLO WORLD!&quot;输入cout空间并输出到屏幕，换行</span><br><span class="line">    return 0;                                                          //返回整数0，一般有返回值的函数没写这一句也默认返回值是0</span><br><span class="line">&#125;                                                                               //&quot;&#123;&#125;&quot;内是一个完整的代码块</span><br></pre></td></tr></table></figure>
<p>模板：注意代码规范，可用Tab键缩进	可保留错误代码并注释掉用于复习<br>#include<iostream><br>using namespace std;</p>
<p>int main()                   &#x2F;&#x2F;注释单行用”&#x2F;&#x2F;“这个符号，了解编译器或者集成环境IDE的快捷注释按键，方便注释不用的代码<br>{}<br>多行注释 <code>/**/</code> </p>
<p>二、数据类型(变量与常量) data type (variable &amp; constance) </p>
<pre><code>知识补充：
• 1.存储单位：
</code></pre>
<p>①位(bit)：即比特，计算机的最小存储单位。常见的民用计算机的机器语言只有”0”和”1”两位数字(二进制)，一位存储单位里面只能是”0”或者”1”。你可能已经在你的计算机见过的类似“32位”或者“64位”操作系统的描述之类的。<br>②字节(byte)：一字节等于八位，1byte &#x3D; 8bits<br> 一个英文字母或者数字是一个字节，而汉字是两个字节。<br>    • 2.进制<br>①二进制 Base-2：01<br>从〇开始，逢二进一(位)<br>②十进制 Base-10：0123456789<br>③十六进制 Base-16：珠算就是，但我们要讲的是计算机，所以记住这个：0123456789ABCDEF(到10换成英文字母表就行)<br>以下的稍微了解就行：<br>④八进制：半斤八两（早期计量单位换算）<br>⑤十二进制：一年有十二个月<br>2.1.进制间的换算<br>①十进制换算成二进制：十进制数除以二，直到除数比被除数大，也就是余数变成0为止，从下至上取余数。<br>②二进制换算成十进制：比如：1010 &#x3D;1<em>2^(4-1)+0</em>2^(3-1)+1<em>2^(2-1)+0</em>2^(1-1) &#x3D; 10</p>
<p>1.变量 variable :提供可命名的存储空间，变量类型决定其大小、内存布局及可用操作集。</p>
<p>1.1 基本数据类型 fundamental data types：<br>1.1.0 void：该函数为空值，不能指定为一个变量的数据类型，通常用于描述函数的返回值类型，即不返回任何内容。</p>
<p>1.1.1 整数数据类型<br>①整型 int ：<br>int	整数类型，通常为4个字节，用于存储整数，小数点后的数据会被直接忽略(不四舍五入)<br>short	短整型，&lt;&#x3D; int<br>long	长整型,  &gt;&#x3D; int<br>long long	长长整型</p>
<p>②字符型 char :<br>char	字符型，1byte</p>
<p>③布尔类型 bool<br>bool	布尔类型，结果为真True或假False，1bytes</p>
<p>1.1.2 浮点数据类型<br>①浮点型 float : 由整数部分和小数点后面的小数部分组成，输入计算机后将以科学计数法来表示，en表示10的n次方。<br>float(单精度)	单精度浮点型，4bytes<br>double(双精度)	双精度浮点型，&gt;&#x3D; float</p>
<p>1.1.3 str()类型<br>④字符串 string :<br>String	字符串，可以用str()函数将任意整型和浮点型转为字符串</p>
<p>1.2.0 关于变量的分类<br>全局变量与局部变量：函数内或者函数的参数列表内的变量为局部变量，而函数外部定义的变量为全局变量。函数可以引用外部的变量，而外部却不可以引用内部变量。</p>
<p>1.2.1 变量地址<br>创建的每一个变量都会分配相应数据类型大小的存储空间，所有变量中的数字会以16进制存储在计算机中，该空间中每1个内存槽为1个字节，也就是每段有8位。当变量被创建后，相应的内存也会被划分出来与变量绑定，也就是说无法将其他变量指定给该内存位置。被创建的变量有了特定的存储段，这些段驻留在硬件上并分配了一个特定数字作为他的地址以便计算机定位该存储段并读取其中的1和0进行翻译，而这个地址就是变量地址。通常该地址为存储段的第一个字节。(指针)</p>
<p>2.常量 const :<br>①数字(值)<br>②字符字面值与字符串字面值：输入的”字符”在开辟的空间中会以值的形式保存(而不是字符本身，字符是给人看的，计算机在实际运算中用的是值)。<br>③加上关键字’const’的变量，如：const string my_TutorialStr</p>
<p>3.命名规范 :<br>①Camel Case(驼峰命名法)  eg(例子) : myFunctionA 头部单词小写，两个“驼峰”的单词首字母大写。这样的写法较为易读。<br>②不要与标识符与关键字重复！！！(重点)<br>诸如：int、for、return等等这些在编译器内部是有用处的，不能用于命名(否则计算机因为识别成相关用途而导致编译出错)。<br>但是像”<em>int”这样的就没问题，”</em>“是分隔符，常用来在变量名中分隔单词，如：”my_name”这样的命名。<br>③数字不要放在变量名开头！！！(重点)<br>④尽量不要加一些奇奇怪怪的符号，容易出错。一般情况下命名纯英文就好(不排除不支持中文的情况，笔者并非都试过，你可以试试)。</p>
<p>4.语法</p>
<p>①进入函数，输出一个局部变量<br>数据类型 函数名(参数列表)<br>{<br>    数据类型 变量名；<br>    变量名 &#x3D; 值；<br>    cout &lt;&lt; 变量名 &lt;&lt; endl;<br>}</p>
<p>5.实操<br>①<br>#include<iostream><br>using namespace std;</p>
<p>void main()                           &#x2F;&#x2F;定义了返回值为void的主函数<br>{<br>    int a;                            &#x2F;&#x2F;定义了一个整型a<br>    a &#x3D; 1;                           &#x2F;&#x2F;将1赋值给a<br>    cout &lt;&lt; a &lt;&lt; endl;     &#x2F;&#x2F;输出a到屏幕上<br>}</p>
<p>②<br>#include<iostream><br>using namespace std;</p>
<p>int main()                                    &#x2F;&#x2F;要不要试试写两个主函数会怎么样？<br>{<br>    int x;                                   &#x2F;&#x2F;定义一个整型x，此处开辟了一个名字是x的变量空间，可以用来存储数据<br>    x &#x3D; 1;                                 &#x2F;&#x2F;将1赋值给x，注意这里的”&#x3D;”不是等于号而是赋值，后面运算符会讲到</p>
<pre><code>short b = 2;                       //你可能会在游戏加载界面看到「正在初始化」这样的语句，定义一个变量并赋值就叫做&quot;初始化&quot;

long c(3);                          //初始化不用&quot;=&quot;而是用&quot;()&quot;来传递括号内的值给变量也是可以的

x = 5;                                //试着给x重新赋值，此时变量空间里的1被5代替，也就是覆写(overwritten)

cout &lt;&lt; x &lt;&lt; endl;          //输出赋值后的变量到你的屏幕看看
cout &lt;&lt; b &lt;&lt; endl;
cout &lt;&lt; c &lt;&lt; endl;

char myCharA = &#39;a&#39;;               //此处数据类型是字符而不是字符串，所以要用单引号传递单个字符
cout &lt;&lt; myCharA &lt;&lt; endl;

string myStringA = &quot;abc&quot;
cout &lt;&lt; myStringA &lt;&lt; &quot;\n&quot;; //此处的&quot;\n&quot;与endl一样可用来换行，不同的是endl会刷新缓冲

system(&quot;pause&quot;);                   //停止窗口，方便你继续操作。你也许可以试试把这句换成&quot;return;&quot;，编译完成后窗口会自动关闭
//按下F5，Debug，启动！
</code></pre>
<p>}                                                     </p>
<p>三、运算符与优先级、转义符与标识符<br>1.算术运算符<br>运算符	描述	实例<br>+	把两个操作数相加	A + B 将得到 30<br>-	从第一个操作数中减去第二个操作数	A - B 将得到 -10<br>*	把两个操作数相乘	A * B 将得到 200<br>&#x2F;	分子除以分母	B &#x2F; A 将得到 2<br>%	取模运算符，整除后的余数	B % A 将得到 0<br>++	自增运算符，整数值增加 1	A++ 将得到 11<br>–	自减运算符，整数值减少 1	A– 将得到 9</p>
<p>增量运算符：<br>①前自增(减) ++a, –a : 先执行a+1，a-1的操作后赋值<br>②后自增(减) a++, a– : 先执行赋值，后将a+1，a-1之后的字面量在函数中保存为副本，以便下次使用</p>
<p>2.关系运算符<br>运算符	描述	实例<br>&#x3D;&#x3D;	检查两个操作数的值是否相等，如果相等则条件为真。	(A &#x3D;&#x3D; B) 为假。<br>!&#x3D;	检查两个操作数的值是否相等，如果不相等则条件为真。	(A !&#x3D; B) 为真。</p>
<blockquote>
<p>检查左操作数的值是否大于右操作数的值，如果是则条件为真。	(A &gt; B) 为假。<br>&lt;	检查左操作数的值是否小于右操作数的值，如果是则条件为真。	(A &lt; B) 为真。<br>&#x3D;	检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。	(A &gt;&#x3D; B) 为假。<br>&lt;&#x3D;	检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。	(A &lt;&#x3D; B) 为真。</p>
</blockquote>
<p>3.逻辑运算符<br>运算符	描述	实例<br>&amp;&amp;	称为逻辑与运算符。如果两个操作数都非零，则条件为真。	(A &amp;&amp; B) 为假。<br>||	称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。	(A || B) 为真。<br>!	称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。	!(A &amp;&amp; B) 为真。</p>
<p>分类.单目运算符与双目运算符</p>
<p>4.其他运算符：取地址运算符”&amp;”<br>5.转义符与ASCII码<br>6.标识符<br>7.访问修饰符：<br>（缺省）无修饰符<br>public private protected</p>
<p>四、语句与表达式 statement &amp; expression<br>1.statement : combine what you input and return a value. Like: 1+1,”here a sentence”.<br>2.expression : execute in sequence and carry out some action. Like: int x;<br>3.expression statement : statement that cause expression to be evaluated. Like: x &#x3D; 1;</p>
<p>五、真值和字面值(量)<br>1.真值 True or False<br>①0的真值永远是假False，无论数据类型，其余则被计算机视为真True。<br>②真值可以用于控制语句不同情况下是否执行。<br>③所有字符都有一个数字值，因此也具有真值。</p>
<p>2.字面值：<br>在C++中，我们会常用1~10以及True之类的人类能看懂的字符来表示赋值给变量对应的常量值或者真值，名为其实，这些就叫做字面值。</p>
<p>六、作用域 Scope<br>{block;}花括号里的即代码的「作用域」，从左花括号到右花括号的区域也叫做「块」。在特定块的范围内创建一个变量，该变量具有局部作用域，即该变量只能作用于该区域内部而不能直接从外部调用，这种变量也称作「局部变量」。而在作用域之外的变量则称作「全局变量」，所有块中均可调用该变量。</p>
<p>七、if_else if条件循环语句和switch语句<br>①多次检查条件<br>if(condition)<br>{<br>    表达式或语句;<br>}<br>else if<br>{<br>    表达式或语句;<br>}<br>②检查一次条件<br>switch(selection)<br>{<br>    case 1:<br>    表达式或语句；<br>    break;<br>    case 2:<br>    表达式或语句；<br>    case 3:<br>    表达式或语句；<br>    break；<br>    …<br>}</p>
<p>八、do_while()循环语句和for循环语句<br>①先执行再判断条件，不满足则跳出循环(break out)<br>do<br>{<br>    表达式或语句;<br>}while(控制语句);<br>while(控制语句)<br>{<br>    表达式或语句;<br>}<br>②先判断执行条件，满足则进入循环，在指定条件和次数内不断迭代<br>for(初始化 Initialization;控制语句 Condition Evaluation;自增语句 Increment)<br>{<br>    表达式或语句;<br>}</p>
<p>九、函数 function(参数列表)<br>①函数原型(与C语言最大的不同)<br>如果在没有函数原型的情况下直接将你定义的函数放在主函数的下方会怎样？<br>②函数重载(函数名相同，传参不同)<br>当你需要重复利用一个函数，但需要他输出不同的数据类型的变量时，可以使用函数重载。</p>
<p>十、初始化<br>1.等号赋值<br>2.括号初始化<br>①()<br>②{}</p>
<p>十一、引用<br>为函数创建别名的方法。(类似于程序本身和快捷方式的关系)</p>
<p>注：引用必须在声明时初始化。(与指针的不同之处)</p>
<p>例如，你创建了一个函数，你想改变函数内的变量，而不是用一个新的常量字面值副本去替换原来的副本赋值给变量。你可以创建一个新的函数，通过取地址运算符”&amp;”获得其输入参数中的变量地址并获取该地址，之后会复制一个该地址的副本，并将这个新函数作为前一个函数的别名，这样他们就实际上使用的是相同的内存。</p>
<p>void function(int&amp; variable)；</p>
<p>int main()<br>{<br>    int my_var &#x3D; 1;<br>    function(my_var);<br>}</p>
<p>void function(int&amp; variable &#x3D; 2)<br>{<br>    cout &lt;&lt; variable &lt;&lt; endl;<br>}</p>
<p>十二、数组 arr[] –一个变量多个值<br>①arr[n] &#x3D; {1,2,3,4…n};<br>②利用for循环迭代来输出数组<br>③数组的内存空间连续</p>
<p>十三、枚举 enum<br>1.枚举是你自定义了一种数据类型，但事实上并没有创建一个实例或者变量，后续你可以通过声明来创建该数据类型的变量。<br>2.试着用switch语句来为枚举的自定义数据类型下的变量创建多个事件，这样当你想更新变量时不用经历繁复的检测，而是从多个事件中选择相应的事件，比if语句更加高效。</p>
<p>名词解释：<br>实例（instance）：在面向对象程序设计中，“类”在实例化之后叫做一个“实例”。 “类”是静态的，不占进程内存，而“实例”拥有动态内存。<br>实例和对象基本上是同义词，它们常常可以互换使用。对象代表了类的一个特定的实例。对象具有身份（identity）和属性值（attribute values）2个特征。实例是对象的具体表示，操作可以作用于实例，实例可以有状态地存储操作结果。实例被用来模拟现实世界中存在的、具体的或原型的东西。<br>实例与对象的区别：对象就是类的特定实例，所有的对象都是实例，但并不是所有的实例都是对象。例如，一个关联（UML关系中的一种）的实例不是一个对象，它只是一个实例、一个连接。我们常见的实例都是类的实例，此时二者没有区别。除了类的实例外的实例都不是对象。</p>
<p>示例：<br>#include<iostream><br>using namespace std;</p>
<p>enum Playerstatus<br>{<br>    ps_default,<br>    ps_walk,<br>    ps_run,<br>    ps_attack,<br>    ps_beatk<br>};</p>
<p>enum movement<br>{<br>    move_defalt<br>};</p>
<p>int main()<br>{<br>    Playerstatus status;<br>    status &#x3D; Playerstatus::ps_default;</p>
<pre><code>if (status == Playerstatus::ps_default)
&#123;
    cout &lt;&lt; &quot;status already&quot; &lt;&lt; endl;
&#125;

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>十四、结构体 struct</p>
<p>枚举与结构体？</p>
<p>十五、指针 pointer<br>1.基本特点<br>①使用场景：我们需要使用变量时，往往需要函数里的输入参数，而这个参数有可能会是非常长的数组或者结构体有着庞大的变量与函数的容器等等类似的，在内存中传递大的对象非常低效，程序会变慢，且这种情况在游戏中玩家是可视的，此时与其传递变量本身，不如直接传递该变量地址(一串数字)，这是需要用到”指针”，”指针”就是保存其他变量地址的变量。之后我们就可以使用该地址访问变量并获得相应数据。<br>②内存地址一般以十六进制显示<br>③指针不需要像引用一样在声明时初始化。</p>
<p>示例：<br>#include<iostream><br>using namespace std;</p>
<p>int main()<br>{<br>    int a &#x3D; 100;</p>
<pre><code>int* aPtr;
aPtr = &amp;a;

cout &lt;&lt; aPtr &lt;&lt; endl; //输出变量地址

cout &lt;&lt; *aPtr &lt;&lt; endl; //解引用指针，输出变量

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>2.指针传递数组：传递的是数组第一个元素的地址(数组的内存空间是连续的)</p>
<p>示例：<br>①执行下面代码试一试<br>#include<iostream><br>using namespace std;</p>
<p>int main()<br>{<br>    int a[] &#x3D; {0,1,2,3,4,5};<br>    int* aPtr;<br>    aPtr &#x3D; &a;</p>
<pre><code>cout &lt;&lt; aPtr &lt;&lt; endl; //输出变量地址

cout &lt;&lt; *aPtr &lt;&lt; endl; //解引用指针，输出变量

aPtr++;

cout &lt;&lt; *aPtr &lt;&lt; endl; //解引用指针，输出变量

aPtr++;

cout &lt;&lt; *aPtr &lt;&lt; endl; //解引用指针，输出变量

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>②<br>#include<iostream><br>using namespace std;</p>
<p>int main()<br>{<br>    int a[] &#x3D; {0,1,2,3,4,5};<br>    int* aPtr;<br>    aPtr &#x3D; a;           &#x2F;&#x2F;数组名代表其中第一个元素的地址，因而不需要取址符</p>
<pre><code>cout &lt;&lt; aPtr &lt;&lt; endl; //输出变量地址

cout &lt;&lt; *aPtr &lt;&lt; endl; //解引用指针，输出变量

aPtr++;

cout &lt;&lt; *aPtr &lt;&lt; endl; //解引用指针，输出变量

aPtr++;

cout &lt;&lt; *aPtr &lt;&lt; endl; //解引用指针，输出变量

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>3.指针传递结构体<br>4.多重指针<br>5.堆与栈 Heap and Stack<br>5.1动态内存<br>①是什么<br>栈用于存储主函数等静态变量，调用这些静态变量时需要将栈顶的函数取出直到取出该变量所在的函数。堆则提供了动态内存，可以随时添加和删除动态内存里的函数和变量，在创建这些函数和变量时，使用new关键字在栈的构造函数中创建指针（变量），赋值给成员变量和函数，并返回获取的地址，从而让栈得以访问堆，实现类在构造函数中动态分配内存的目的。<br>②为什么要动态分配内存<br>空指针与野指针</p>
<p>5.2 实操<br>①谨慎尝试下面代码<br>#include<iostream><br>#include<string><br>using namespace std;</p>
<p>struct Character<br>{<br>    string Name;<br>    float Health;<br>};</p>
<p>int main()<br>{<br>    for (int i &#x3D; 0; i &lt; 100000000;i++)<br>    {<br>        Character* PtrToChar &#x3D; new Character();</p>
<pre><code>    PtrToChar-&gt;Name = &quot;114514aaaaaaa&quot;;

    cout &lt;&lt; PtrToChar-&gt;Name &lt;&lt; endl;
&#125;

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;上方的代码使用了new关键字，导致进程循环在堆中创建新的实例占用内存空间，而没有去释放空间，造成内存泄漏<br>②<br>#include<iostream><br>#include<string><br>using namespace std;</p>
<p>struct Character<br>{<br>    string Name;<br>    float Health;<br>};</p>
<p>int main()<br>{<br>    for (int i &#x3D; 0; i &lt; 100000000;i++)<br>    {<br>        Character* PtrToChar &#x3D; new Character();</p>
<pre><code>    PtrToChar-&gt;Name = &quot;114514aaaaaaa&quot;;

    cout &lt;&lt; PtrToChar-&gt;Name &lt;&lt; endl;

    delete PtrToChar;
&#125;

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>③<br>#include<iostream><br>#include<string><br>using namespace std;</p>
<p>struct Character<br>{<br>    Character();</p>
<pre><code>void PrintHealth();

string Name;
float Health;
</code></pre>
<p>};</p>
<p>Character::Character()<br>{<br>    Name &#x3D; “Default Name”;<br>    Health &#x3D; 100.f;<br>}</p>
<p>void Character::PrintHealth()<br>{<br>    cout &lt;&lt; “Health is:” &lt;&lt; Health &lt;&lt; endl;<br>}</p>
<p>int main()<br>{<br>    for (int i &#x3D; 0; i &lt; 10;i++)<br>    {<br>        Character* PtrToChar &#x3D; new Character();</p>
<pre><code>    cout &lt;&lt; PtrToChar-&gt;Name &lt;&lt; endl;

    PtrToChar-&gt;PrintHealth();

    delete PtrToChar;
&#125;

system(&quot;pause&quot;);
</code></pre>
<p>}<br>&#x2F;&#x2F;思考什么时候指针需要解引用，什么时候不需要？(普通成员函数与类成员函数)</p>
<p>十六、对象和类</p>
<ol>
<li></li>
</ol>
<p>示例：<br>#include<iostream><br>#include<string><br>using namespace std;</p>
<p>class Player<br>{<br>    string Name;<br>    int Age;<br>    float Hitpoint;</p>
<pre><code>void Attack()
&#123;
    cout &lt;&lt; &quot;Succeed&quot; &lt;&lt; endl;
&#125;
</code></pre>
<p>};</p>
<p>int main()<br>{<br>    Player p1;<br>    Player p2;</p>
<pre><code>system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>2.构造函数(constructor)与完全限制名称：类中可以包含函数，当类体内没有函数时可以调用自动创建的默认构造函数，构造函数可以在类外部初始化类变量值，在类外部为其变量提供默认值，构造函数命名与类名相同，且构造函数没有返回值，不能说明返回类型为void。</p>
<p>实例：<br>①执行下面代码试一试<br>#include<iostream><br>#include<iostream><br>using namespace std;</p>
<p>class Dog<br>{<br>    string name;<br>    int age;<br>    float Health;</p>
<pre><code>void Bark()
&#123;
    cout &lt;&lt; &quot;Woof!&quot; &lt;&lt; endl;
&#125;
</code></pre>
<p>};</p>
<p>int main()<br>{<br>    &#x2F;&#x2F;主函数内定义dog类的实例dog<br>    Dog dog;</p>
<pre><code>dog.Bark();

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>②<br>#include<iostream><br>#include<iostream><br>using namespace std;</p>
<p>class Dog<br>{<br>    &#x2F;&#x2F;先公开类，因为类体内默认私有变量<br>public:<br>    string name;<br>    int age;<br>    float Health;</p>
<pre><code>void Bark()
&#123;
    cout &lt;&lt; &quot;Woof!&quot; &lt;&lt; endl;
&#125;
</code></pre>
<p>};</p>
<p>int main()<br>{<br>    &#x2F;&#x2F;主函数内定义dog类的实例dog<br>    Dog dog;<br>   &#x2F;&#x2F;调用对象内的函数Bark<br>    dog.Bark();</p>
<pre><code>system(&quot;pause&quot;);
</code></pre>
<p>}<br>&#x2F;&#x2F;到这里，你已经清楚了结构体的默认访问修饰符是public,而类默认private，所以要将其公开来访问其中的变量和函数<br>&#x2F;&#x2F;那如果我们想要Bark函数在dog实例被创建后立即调用该怎么做？</p>
<p>③<br>#include<iostream><br>#include<iostream><br>using namespace std;</p>
<p>class Dog<br>{<br>public:<br>    Dog()<br>    {<br>        Bark();<br>    }<br>    string name;<br>    int age;<br>    float Health;</p>
<pre><code>void Bark()
&#123;
    cout &lt;&lt; &quot;Woof!&quot; &lt;&lt; endl;
&#125;
</code></pre>
<p>};</p>
<p>int main()<br>{<br>    &#x2F;&#x2F;主函数内定义dog类的实例dog<br>    Dog dog;</p>
<pre><code>system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>④类内声明，类外定义<br>#include<iostream><br>#include<iostream><br>using namespace std;</p>
<p>class Dog<br>{<br>public:<br>    Dog();</p>
<pre><code>string name;
int age;
float Health;

void Bark();
</code></pre>
<p>};</p>
<p>int main()<br>{<br>    &#x2F;&#x2F;declear variable dog of class Dog inside main function,instance will be created<br>    &#x2F;&#x2F;his constructor will be automatically called and the function Dog will run<br>    Dog dog;</p>
<pre><code>//access the member vairable with dopt operator
cout &lt;&lt; dog.name &lt;&lt; endl;
cout &lt;&lt; dog.age &lt;&lt; endl;
cout &lt;&lt; dog.Health &lt;&lt; endl;

dog.name = &quot;Nameless&quot;;
dog.age = 18;
dog.Health = 100.f;

cout &lt;&lt; dog.name &lt;&lt; endl;
cout &lt;&lt; dog.age &lt;&lt; endl;
cout &lt;&lt; dog.Health &lt;&lt; endl;

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>Dog::Dog()<br>{<br>    Bark();<br>    name &#x3D; “Default Name”;<br>    age &#x3D; 10;<br>    Health &#x3D; 100.f;<br>}</p>
<p>void Dog::Bark()<br>{<br>    cout &lt;&lt; “Woof!” &lt;&lt; endl;<br>}</p>
<p>⑤对比构造体<br>#include<iostream><br>#include<string><br>using namespace std;</p>
<p>struct Cat<br>{<br>    &#x2F;&#x2F;重载<br>    Cat();</p>
<pre><code>string a;
int b;

void Meow();
</code></pre>
<p>};</p>
<p>Cat::Cat()<br>{<br>    a &#x3D; “Meow”;<br>    b &#x3D; 1;</p>
<pre><code>Meow();
</code></pre>
<p>}</p>
<p>void Cat::Meow()<br>{<br>    cout &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; b &lt;&lt; endl;<br>}</p>
<p>int main()<br>{<br>    Cat cat;<br>    system(“pause”);<br>}</p>
<p>⑥<br>&#x2F;&#x2F;requirement:use struct or class,output a number pair which you can input num for it<br>#include<iostream><br>using namespace std;</p>
<p>class a<br>{<br>public:<br>    int x, y;<br>    void setPoint();</p>
<pre><code>void numPair();
</code></pre>
<p>};</p>
<p>void a::setPoint()<br>{<br>    cout &lt;&lt; “please input num as X” &lt;&lt; endl;<br>    cin &gt;&gt; x;</p>
<pre><code>cout &lt;&lt; &quot;please input num as Y&quot; &lt;&lt; endl;
cin &gt;&gt; y;

numPair();
</code></pre>
<p>}</p>
<p>void a::numPair()<br>{<br>    cout &lt;&lt; “(“ &lt;&lt; x &lt;&lt; “,” &lt;&lt; y &lt;&lt; “)” &lt;&lt; endl;<br>}</p>
<p>int main()<br>{<br>    a np;<br>    &#x2F;&#x2F;注意此处的setPoint()与上个案例中的构造函数Cat不同，此处并非构造函数，因而需要调用该方法<br>    np.setPoint();<br>    system(“pause”);<br>}</p>
<p>3.子类</p>
<p>①无子类，通过有参构造函数初始化变量或者重载构造函数并传参到主函数进行初始化值<br>#include<iostream><br>using namespace std;</p>
<p>class animal<br>{<br>public:<br>    animal();<br>    &#x2F;&#x2F;overload<br>    animal(string Name,string Species, int Count);</p>
<pre><code>string name;
string species;

int count;

void info();
</code></pre>
<p>};</p>
<p>animal::animal()<br>{<br>    name &#x3D; “niu”;<br>    species &#x3D; “cow”;<br>    count &#x3D; 2;<br>    cout &lt;&lt; “an animal” &lt;&lt; endl;<br>}</p>
<p>animal::animal(string Name, string Species, int Count)<br>{<br>    &#x2F;&#x2F;参数列表中使用占位符，此处用占位符即可，传参到主函数中初始化<br>    name &#x3D; Name;<br>    species &#x3D; Species;<br>    count &#x3D; Count;<br>    cout &lt;&lt; “again” &lt;&lt; endl;<br>}</p>
<p>void animal::info()<br>{<br>    cout &lt;&lt; “name:” &lt;&lt; name &lt;&lt; endl;<br>    cout &lt;&lt; “type:” &lt;&lt; species &lt;&lt; endl;<br>    cout &lt;&lt; “count:” &lt;&lt; count &lt;&lt; endl;<br>}</p>
<p>int main()<br>{</p>
<pre><code>animal anm;
anm.info();

animal anm2(&quot;tu&quot;,&quot;rabbit&quot;,2);
anm2.info();

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>②有参构造与初始化列表<br>#include<iostream><br>using namespace std;</p>
<p>class animal<br>{<br>public:<br>    animal();<br>    &#x2F;&#x2F;overload<br>    animal(string Name,string Species, int Count);</p>
<pre><code>string name;
string species;

int count;

void info();
</code></pre>
<p>};</p>
<p>animal::animal()<br>{<br>    name &#x3D; “niu”;<br>    species &#x3D; “cow”;<br>    count &#x3D; 2;<br>    cout &lt;&lt; “an animal” &lt;&lt; endl;<br>}</p>
<p>&#x2F;&#x2F;初始化列表<br>animal::animal(string Name, string Species, int Count):name(“tutu”),species(“rabbit”),count(3)<br>{<br>    cout &lt;&lt; “nin chi le ma?” &lt;&lt; endl;<br>}</p>
<p>void animal::info()<br>{<br>    cout &lt;&lt; “name:” &lt;&lt; name &lt;&lt; endl;<br>    cout &lt;&lt; “type:” &lt;&lt; species &lt;&lt; endl;<br>    cout &lt;&lt; “count:” &lt;&lt; count &lt;&lt; endl;<br>}</p>
<p>int main()<br>{</p>
<pre><code>animal anm;
anm.info();

animal anm2(&quot;tu&quot;,&quot;rabbit&quot;,2);
anm2.info();

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>3.1继承<br>①子类<br>#include<iostream><br>using namespace std;</p>
<p>class animal<br>{<br>public:<br>    animal();<br>    &#x2F;&#x2F;overload<br>    animal(string Name, string Species, int Count);</p>
<pre><code>string name;
string species;

int count;

void info();
</code></pre>
<p>};</p>
<p>&#x2F;&#x2F;创建子类，注意此处的访问修饰符只是针对父类。<br>class Dog:public animal<br>{<br>public:<br>    Dog();</p>
<p>};</p>
<p>int main()<br>{</p>
<pre><code>Dog dog;
dog.info();

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>animal::animal()<br>{<br>    name &#x3D; “niu”;<br>    species &#x3D; “cow”;<br>    count &#x3D; 2;<br>    cout &lt;&lt; “an animal” &lt;&lt; endl;<br>}</p>
<p>animal::animal(string Name, string Species, int Count) :name(“tutu”), species(“rabbit”), count(3)<br>{<br>    cout &lt;&lt; “nin chi le ma?” &lt;&lt; endl;<br>}</p>
<p>void animal::info()<br>{<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; “name:” &lt;&lt; name &lt;&lt; endl;<br>    cout &lt;&lt; “type:” &lt;&lt; species &lt;&lt; endl;<br>    cout &lt;&lt; “count:” &lt;&lt; count &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>}</p>
<p>Dog::Dog()<br>{<br>    &#x2F;&#x2F;因为子类的构造函数Dog()不含参，因而默认调用的是父类不含参的animal()函数<br>    &#x2F;&#x2F;程序将优先调用父类构造函数(观察程序输出顺序)<br>    info();<br>    cout &lt;&lt; “here” &lt;&lt; endl;<br>}</p>
<p>②如果要调用父类重载的构造函数呢？试试下面的代码<br>#include<iostream><br>using namespace std;</p>
<p>class animal<br>{<br>public:<br>    animal();<br>    &#x2F;&#x2F;overload<br>    animal(string Name, string Species, int Count);</p>
<pre><code>string name;
string species;

int count;

void info();
</code></pre>
<p>};</p>
<p>class Dog:public animal<br>{<br>public:<br>    Dog();<br>    Dog(string Name,string Species,int Count);</p>
<p>};</p>
<p>int main()<br>{<br>    &#x2F;&#x2F;此处初始化之后，看看程序输出的是什么？<br>    Dog dog{“pipi”,”pig”,3};<br>    dog.info();</p>
<pre><code>system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>animal::animal()<br>{<br>    name &#x3D; “niu”;<br>    species &#x3D; “cow”;<br>    count &#x3D; 2;<br>    cout &lt;&lt; “an animal” &lt;&lt; endl;<br>}</p>
<p>animal::animal(string Name, string Species, int Count) :name(“tutu”), species(“rabbit”), count(3)<br>{<br>    cout &lt;&lt; “nin chi le ma?” &lt;&lt; endl;<br>}</p>
<p>void animal::info()<br>{<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; “name:” &lt;&lt; name &lt;&lt; endl;<br>    cout &lt;&lt; “type:” &lt;&lt; species &lt;&lt; endl;<br>    cout &lt;&lt; “count:” &lt;&lt; count &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>}</p>
<p>Dog::Dog()<br>{<br>    &#x2F;&#x2F;因为子类的构造函数Dog()不含参，因而调用的是父类不含参的animal()函数<br>    &#x2F;&#x2F;程序将优先调用父类构造函数<br>    info();<br>    cout &lt;&lt; “here” &lt;&lt; endl;<br>}</p>
<p>Dog::Dog(string Name, string Species, int Count)<br>{<br>    cout &lt;&lt; “happy happy happy” &lt;&lt; endl;<br>}</p>
<p>③调用父类重载有参构造函数<br>#include<iostream><br>using namespace std;</p>
<p>class animal<br>{<br>public:<br>    animal();<br>    &#x2F;&#x2F;overload<br>    animal(string Name, string Species, int Count);</p>
<pre><code>string name;
string species;

int count;

void info();
</code></pre>
<p>};</p>
<p>class Dog:public animal<br>{<br>public:<br>    Dog();<br>    Dog(string Name,string Species,int Count);</p>
<p>};</p>
<p>int main()<br>{<br>    &#x2F;&#x2F;为何值与此处不同？如果想用这种方法初始化该如何解决？<br>    Dog dog{“pipi”,”pig”,3};<br>    dog.info();</p>
<pre><code>system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>animal::animal()<br>{<br>    name &#x3D; “niu”;<br>    species &#x3D; “cow”;<br>    count &#x3D; 2;<br>    cout &lt;&lt; “an animal” &lt;&lt; endl;<br>}</p>
<p>animal::animal(string Name, string Species, int Count) :name(“tutu”), species(“rabbit”), count(3)<br>{<br>    cout &lt;&lt; “nin chi le ma?” &lt;&lt; endl;<br>}</p>
<p>void animal::info()<br>{<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; “name:” &lt;&lt; name &lt;&lt; endl;<br>    cout &lt;&lt; “type:” &lt;&lt; species &lt;&lt; endl;<br>    cout &lt;&lt; “count:” &lt;&lt; count &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>}</p>
<p>Dog::Dog()<br>{<br>    &#x2F;&#x2F;因为子类的构造函数Dog()不含参，因而调用的是父类不含参的animal()函数<br>    &#x2F;&#x2F;程序将优先调用父类构造函数<br>    info();<br>    cout &lt;&lt; “here” &lt;&lt; endl;<br>}</p>
<p>&#x2F;&#x2F;子类调用父类重载构造函数语法<br>Dog::Dog(string Name, string Species, int Count):animal(Name,Species,Count)<br>{<br>    cout &lt;&lt; “happy happy happy” &lt;&lt; endl;<br>}</p>
<p>&#x2F;&#x2F;能否默认优先调用子类构造函数？</p>
<p>④<br>&#x2F;&#x2F;#include<iostream><br>&#x2F;&#x2F;using namespace std;<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;int main()<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;}</p>
<p>#include<iostream><br>using namespace std;</p>
<p>class animal<br>{<br>public:<br>    animal();<br>    &#x2F;&#x2F;overload<br>    animal(string Name, string Species, int Count);</p>
<pre><code>string name;
string species;

int count;

void info();
</code></pre>
<p>};</p>
<p>class Dog:public animal<br>{<br>public:<br>    Dog();<br>    Dog(string Name,string Species,int Count);</p>
<p>};</p>
<p>int main()<br>{<br>    &#x2F;&#x2F;为何值与此处不同？如果想用这种方法初始化该如何解决？<br>    Dog dog{“pipi”,”pig”,3};<br>    dog.info();</p>
<pre><code>system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>animal::animal()<br>{<br>    name &#x3D; “niu”;<br>    species &#x3D; “cow”;<br>    count &#x3D; 2;<br>    cout &lt;&lt; “an animal” &lt;&lt; endl;<br>}</p>
<p>animal::animal(string Name, string Species, int Count) :name(“tutu”), species(“rabbit”), count(3)<br>{<br>    cout &lt;&lt; “nin chi le ma?” &lt;&lt; endl;<br>}</p>
<p>void animal::info()<br>{<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; “name:” &lt;&lt; name &lt;&lt; endl;<br>    cout &lt;&lt; “type:” &lt;&lt; species &lt;&lt; endl;<br>    cout &lt;&lt; “count:” &lt;&lt; count &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>}</p>
<p>Dog::Dog()<br>{<br>    &#x2F;&#x2F;因为子类的构造函数Dog()不含参，因而调用的是父类不含参的animal()函数<br>    &#x2F;&#x2F;程序将优先调用父类构造函数<br>    info();<br>    cout &lt;&lt; “here” &lt;&lt; endl;<br>}</p>
<p>&#x2F;&#x2F;子类调用父类重载构造函数语法<br>Dog::Dog(string Name, string Species, int Count)<br>{<br>    animal(Name,Species,Count);<br>    cout &lt;&lt; “happy happy happy” &lt;&lt; endl;<br>}</p>
<p>&#x2F;&#x2F;能否默认优先调用子类构造函数？</p>
<p>⑤<br>#include<iostream><br>using namespace std;</p>
<p>class animal<br>{<br>public:<br>    animal();<br>    &#x2F;&#x2F;overload<br>    animal(string Name, string Species, int Count);</p>
<pre><code>string name;
string species;

int count;

void info();
</code></pre>
<p>};</p>
<p>class Dog:public animal<br>{<br>public:<br>    Dog();<br>    Dog(string Name,string Species,int Count);</p>
<p>};</p>
<p>int main()<br>{<br>    &#x2F;&#x2F;Dog子类创建实例dog<br>    Dog dog{“pipi”,”pig”,3};</p>
<pre><code>system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;父类animal重载无参构造函数<br>animal::animal()<br>{<br>    name &#x3D; “niu”;<br>    species &#x3D; “cow”;<br>    count &#x3D; 2;<br>    cout &lt;&lt; “an animal” &lt;&lt; endl;<br>}</p>
<p>&#x2F;&#x2F;父类animal重载有参构造函数<br>animal::animal(string Name, string Species, int Count)<br>    :name(Name), species(Species), count(Count)<br>{<br>    info();<br>    cout &lt;&lt; “nin chi le ma?” &lt;&lt; endl;<br>}</p>
<p>&#x2F;&#x2F;在外部定义父类animal的成员函数info()<br>void animal::info()<br>{<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; “name:” &lt;&lt; name &lt;&lt; endl;<br>    cout &lt;&lt; “type:” &lt;&lt; species &lt;&lt; endl;<br>    cout &lt;&lt; “count:” &lt;&lt; count &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>}</p>
<p>Dog::Dog()<br>{<br>    &#x2F;&#x2F;因为子类的构造函数Dog()不含参，因而调用的是父类不含参的animal()函数<br>    &#x2F;&#x2F;程序将优先调用父类构造函数<br>    info();<br>    cout &lt;&lt; “here” &lt;&lt; endl;<br>}</p>
<p>&#x2F;&#x2F;子类调用父类重载构造函数语法<br>Dog::Dog(string Name, string Species, int Count):animal(Name, Species, Count)<br>{<br>    cout &lt;&lt; “happy happy happy” &lt;&lt; endl;<br>}</p>
<p>&#x2F;&#x2F;能否默认优先调用子类构造函数？</p>
<p>⑥一般情况下，没有定义构造函数的子类会自动调用父类无参构造函数的重载（默认构造函数），但初始化列表使得有参构造函数的重载得以调用而不去调用无参构造函数的重载，如果在子类类体里调用父类有参构造函数的重载，而不是用初始化列表，那么无参和有参的重载都会被调用。在继承中，父类定义的变量和函数都会在继承链上传递，被子类所继承，即便是多重继承，子类也可以调用他们。上述例子的继承关系为“is-a”关系。<br>⑦定义子类时对父类需要使用访问修饰符（access modifiers），访问权限也会被相应的子类继承。<br>public继承：如果定义子类时父类的访问修饰符为public,则无论父类类体内部的变量和函数访问权限如何，子类亦是如此。<br>protected继承：除了父类中访问权限为private的成员变量和函数仍在子类中的访问权限是private，其余的都将以访问权限为protected被子类继承。<br>private继承：若在派生新类使用该关键字，则父类所有的变量和函数访问权限在子类中也都是private。<br>但注意，父类的访问权限可以被子类继承，但子类不一定能够访问继承自父类的这些变量和函数，比如：当父类的成员变量和函数访问权限为private时，这时子类会继承父类成员变量和函数private，但不能直接访问他们（偷家函数）。<br>访问说明符的权限：<br>public全局可以访问，protected只能在同一类以及派生新类中访问，private只能在该类体内访问。后两种访问权限都对子类具有限制性，注意使用时的具体情况。</p>
<p>3.2封装<br>3.2_1.getter 和 setter 访问器函数<br>①试试看<br>#include<iostream><br>using namespace std;</p>
<p>class creatrue<br>{</p>
<p>public:<br>    creatrue();</p>
<p>private:<br>    string name;<br>    float health;</p>
<p>};</p>
<p>int main()<br>{<br>    creatrue Igno;<br>    Igno.name &#x3D; “Igno”;</p>
<pre><code>system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>creatrue::creatrue()<br>{<br>    cout &lt;&lt; “A creatrue has been createed!&#x2F;n”;<br>}<br>②通过Getter和Setter函数访问并修改私有变量<br>#include<iostream><br>using namespace std;</p>
<p>class creature<br>{</p>
<p>public:<br>    creature();</p>
<pre><code>//Getter and Setter to send the Name
void SetName(string Name);
string GetName();
</code></pre>
<p>private:<br>    string name;<br>    float health;</p>
<p>};</p>
<p>int main()<br>{<br>    creature Igor;<br>    Igor.SetName(“w”);</p>
<pre><code>cout &lt;&lt; Igor.GetName() &lt;&lt; endl;

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>creature::creature()<br>{<br>    cout &lt;&lt; “A creatrue has been createed!\n”;<br>}</p>
<p>&#x2F;&#x2F;Setter<br>void creature::SetName(string Name)<br>{<br>    name &#x3D; Name;<br>}</p>
<p>&#x2F;&#x2F;Getter<br>string creature::GetName()<br>{<br>    return name;<br>}</p>
<p>应用场景：<br>某些待解锁权限，例如游戏通关秘钥和道具。</p>
<p>③<br>#include<iostream><br>using namespace std;</p>
<p>class creature<br>{</p>
<p>public:<br>    creature();</p>
<pre><code>//Getter and Setter to send the Name
void SetName(string Name);
string GetName();
void SetHealth(int Health);
int GetHealth();

//HP system
void TakeDamage(float damage);
</code></pre>
<p>private:<br>    string name;<br>    float health;</p>
<p>};</p>
<p>int main()<br>{<br>    creature Igor;<br>    Igor.SetName(“w”);<br>    Igor.SetHealth(100);<br>    Igor.TakeDamage(20);</p>
<pre><code>cout &lt;&lt; Igor.GetName() &lt;&lt; endl;
cout &lt;&lt; Igor.GetHealth() &lt;&lt; endl;

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>creature::creature()<br>{<br>    cout &lt;&lt; “A creatrue has been createed!\n”;<br>}</p>
<p>&#x2F;&#x2F;Setter<br>void creature::SetName(string Name)<br>{<br>    name &#x3D; Name;<br>}</p>
<p>&#x2F;&#x2F;Getter<br>string creature::GetName()<br>{<br>    return name;<br>}</p>
<p>void creature::SetHealth(int Health)<br>{<br>    health &#x3D; Health;<br>}</p>
<p>int creature::GetHealth()<br>{<br>    return health;<br>}</p>
<p>void creature::TakeDamage(float damage)<br>{<br>    health -&#x3D; damage;<br>}</p>
<p>④<br>#include<iostream><br>using namespace std;</p>
<p>class creature<br>{</p>
<p>public:<br>    creature();</p>
<pre><code>//Getter and Setter to send the Name
void SetName(string Name);
string GetName();
void SetHealth(float Health);
int GetHealth();

//HP system
void TakeDamage(float damage);
</code></pre>
<p>private:<br>    string name;<br>    float health;</p>
<p>};</p>
<p>int main()<br>{<br>    creature Igor;<br>    Igor.SetName(“w”);<br>    Igor.SetHealth(100.f);<br>    Igor.TakeDamage(20.f);</p>
<pre><code>cout &lt;&lt; Igor.GetName() &lt;&lt; endl;
cout &lt;&lt; Igor.GetHealth() &lt;&lt; endl;

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>creature::creature()<br>{<br>    cout &lt;&lt; “A creatrue has been createed!\n”;<br>}</p>
<p>&#x2F;&#x2F;Setter<br>void creature::SetName(string Name)<br>{<br>    name &#x3D; Name;<br>}</p>
<p>&#x2F;&#x2F;Getter<br>string creature::GetName()<br>{<br>    return name;<br>}</p>
<p>void creature::SetHealth(float Health)<br>{<br>    health &#x3D; Health;<br>}</p>
<p>int creature::GetHealth()<br>{<br>    return health;<br>}</p>
<p>void creature::TakeDamage(float damage)<br>{<br>    float Total;<br>    Total &#x3D; health - damage;</p>
<pre><code>if (Total &lt;= 0.f)
&#123;
    cout &lt;&lt; name &lt;&lt; &quot;died&quot; &lt;&lt; endl;
&#125;

//为什么在else里无论输出Health还是Total得出来的都是同样的结果，按理来说将Health减去一次damage并赋值给他的时候Total不是要再减一次吗？
else
&#123;
    health -= damage;
    cout &lt;&lt; &quot;health:&quot; &lt;&lt; Total &lt;&lt; endl;
&#125;
</code></pre>
<p>}</p>
<p>4.析构函数(Destructor)：用于销毁。class ~Name()</p>
<p>①析构函数在使用delete关键字后将执行，同构造函数一样，其函数名与类名必须一致，且函数不能说明返回类型（没有返回值）<br>#include<iostream><br>using namespace std;</p>
<p>class Character<br>{<br>public:<br>    Character();<br>    ~Character();<br>};</p>
<p>int main()<br>{<br>    Character* PtrToCha &#x3D; new Character();<br>    delete PtrToCha;<br>    system(“pause”);<br>}</p>
<p>&#x2F;&#x2F;通过输出字符串来检测是否成功执行<br>Character::Character()<br>{<br>    cout &lt;&lt; “the function has been created!” &lt;&lt; endl;<br>}</p>
<p>Character::~Character()<br>{<br>    cout &lt;&lt; “the function has been deleted!” &lt;&lt; endl;<br>}</p>
<p>②<br>#include<iostream><br>using namespace std;</p>
<p>class Character<br>{<br>public:<br>    Character();<br>    ~Character();</p>
<pre><code>int* CharNum;
float* HP;
</code></pre>
<p>};</p>
<p>int main()<br>{<br>    Character* PtrToCha &#x3D; new Character();<br>    delete PtrToCha;</p>
<pre><code>system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;通过输出字符串来检测是否成功执行<br>Character::Character()<br>{<br>    cout &lt;&lt; “the function has been created!” &lt;&lt; endl;</p>
<pre><code>CharNum = new int(1);
HP = new float(100.f);
</code></pre>
<p>}</p>
<p>Character::~Character()<br>{<br>    cout &lt;&lt; “the function has been deleted!” &lt;&lt; endl;</p>
<pre><code>delete CharNum;
delete HP;
</code></pre>
<p>}</p>
<p>十七、静态变量 Static Var<br>1.static variables in functions : 静态变量存在于内存的各个部分（堆）中，例如局部变量。在函数中，局部变量的作用域无法超出函数的生命周期，基本上所有的局部变量都在声明他们的作用域的末尾被销毁，因此调用函数的时候会重复创建变量，初始化，运算然后删除变量的流程。静态变量存在于函数生命周期之外，受作用域影响，直到程序生命周期结束之前静态变量占用的内存都不会被删除，当第二次调用栈内的函数时，第一次初始化的步骤会自动忽略，且能够保证变量不会因为栈的特性而被删除。如果不初始化静态变量，默认初始化为0。<br>①第一种调用静态变量的方法 想想会输出什么？<br>#include<iostream><br>#include<string><br>using namespace std;</p>
<p>void AddToCount()<br>{<br>    static int count &#x3D; 0;<br>    count++;<br>    cout &lt;&lt; count &lt;&lt; endl;<br>}</p>
<p>int main()<br>{<br>    AddToCount();<br>    AddToCount();</p>
<pre><code>system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>②当你在函数内定义静态变量时，虽然静态变量在函数生命周期之外，但你无法从外部访问<br>#include<iostream><br>#include<string><br>using namespace std;</p>
<p>void AddToCount()<br>{<br>    static int count &#x3D; 0;<br>    count++;<br>    cout &lt;&lt; count &lt;&lt; endl;<br>}</p>
<p>int main()<br>{<br>    for (int i &#x3D; 0; i &lt; 100; i++)<br>    {<br>        AddToCount();<br>    }</p>
<pre><code>count--;

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>③局部变量的调用<br>#include<iostream><br>#include<string><br>using namespace std;</p>
<p>class Item<br>{<br>public:<br>    Item()<br>    {<br>        cout &lt;&lt; “an item has been created!\n”;<br>    }<br>    ~Item()<br>    {<br>        cout &lt;&lt; “an item has been destroyed!\n”;<br>    }<br>};</p>
<p>int main()<br>{<br>    &#x2F;&#x2F;局部变量会在声明他的作用域末尾被销毁<br>    Item item;</p>
<pre><code>system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>④上个例子的解决方案：添加作用域<br>#include<iostream><br>#include<string><br>using namespace std;</p>
<p>class Item<br>{<br>public:<br>    Item()<br>    {<br>        cout &lt;&lt; “an item has been created!\n”;<br>    }<br>    ~Item()<br>    {<br>        cout &lt;&lt; “an item has been destroyed!\n”;<br>    }<br>};</p>
<p>int main()<br>{<br>    &#x2F;&#x2F;由于添加了作用域，析构函数会在该作用域末尾执行<br>    {<br>        Item item;<br>    }</p>
<pre><code>system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>⑤第二种调用静态变量的方法<br>#include<iostream><br>#include<string><br>using namespace std;</p>
<p>class Item<br>{<br>public:<br>    Item()<br>    {<br>        cout &lt;&lt; “an item has been created!\n”;<br>    }<br>    ~Item()<br>    {<br>        cout &lt;&lt; “an item has been destroyed!\n”;<br>    }<br>};</p>
<p>int main()<br>{<br>    &#x2F;&#x2F;静态变量不存在于与局部变量相同的内存空间中<br>    {<br>        static Item item;<br>    }</p>
<pre><code>system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>⑥第三种调用静态变量的方式 静态成员变量只能在类外初始化<br>#include<iostream><br>#include<string><br>using namespace std;</p>
<p>class Critter<br>{<br>public:</p>
<pre><code>static int critterCount = 0;
</code></pre>
<p>};</p>
<p>int Critter::critterCount &#x3D; 0;</p>
<p>int main()<br>{</p>
<pre><code>system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>⑦<br>#include<iostream><br>#include<string><br>using namespace std;</p>
<p>class Critter<br>{<br>public:<br>    &#x2F;&#x2F;静态常量<br>    const static int critterCount &#x3D; 0;<br>};</p>
<p>int main()<br>{</p>
<pre><code>system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>⑧无须声明即可使用静态函数 类中静态函数不能定义和声明分开，不能访问非静态成员，不能用对象点的方式调用<br>#include<iostream><br>#include<string><br>using namespace std;</p>
<p>class Critter<br>{<br>public:</p>
<pre><code>Critter()
&#123;
    cout &lt;&lt; &quot;A critter is born!\n&quot;;
    ++critterCount;
&#125;

static void AnnounceCount()
&#123;
    cout &lt;&lt; critterCount &lt;&lt; endl;
&#125;

static int critterCount;
</code></pre>
<p>};</p>
<p>int Critter::critterCount &#x3D; 0;</p>
<p>int main()<br>{<br>    Critter::Critter();<br>    Critter::AnnounceCount();</p>
<pre><code>//Critter crit;
//cout &lt;&lt; Critter::critterCount &lt;&lt; endl;
//Critter crit2;
//cout &lt;&lt; Critter::critterCount &lt;&lt; endl;

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>⑨第四种调用静态变量的方式<br>#include<iostream><br>#include<string><br>using namespace std;</p>
<p>class Critter<br>{<br>public:</p>
<pre><code>Critter()
&#123;
    cout &lt;&lt; &quot;A critter is born!\n&quot;;
    ++critterCount;
&#125;

static void AnnounceCount()
&#123;
    cout &lt;&lt; critterCount &lt;&lt; endl;
&#125;

static int critterCount;
</code></pre>
<p>};</p>
<p>int Critter::critterCount &#x3D; 0;</p>
<p>int main()<br>{<br>    Critter::AnnounceCount();</p>
<pre><code>Critter* crit = new Critter;
Critter::AnnounceCount();
delete crit;

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>十八、虚函数<br>1.在派生子类中对同一函数的定义与父类不相同，使派生子类中的函数有着与父类不同的版本，即重写父类函数。隔代加virtual和override<br>2.区分重写(override)与重载(overload)<br>3.实例：<br>①直接调用会覆盖父级同名函数<br>#include<iostream><br>using namespace std;</p>
<p>class Object<br>{<br>public:<br>    void BeginPlay();<br>};</p>
<p>class Actor:public Object<br>{<br>public:<br>    void BeginPlay();<br>};</p>
<p>int main()<br>{<br>    Object* obj &#x3D; new Object;<br>    obj-&gt;BeginPlay();</p>
<pre><code>Actor* act = new Actor;
act-&gt;BeginPlay();

delete obj;
delete act;

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>void Object::BeginPlay()<br>{<br>    cout &lt;&lt; “Object BeginPlay has been called\n”;<br>}</p>
<p>void Actor::BeginPlay()<br>{<br>    cout &lt;&lt; “Actor BeginPlay has been called\n”;<br>}</p>
<p>②定义并重写继承方法(函数)，将子类限定同名函数放入虚函数表<br>#include<iostream><br>using namespace std;</p>
<p>class Object<br>{<br>public:<br>    virtual void BeginPlay();<br>};</p>
<p>class Actor:public Object<br>{<br>public:<br>    &#x2F;&#x2F;better to add virtual here even if it is<br>    &#x2F;&#x2F;add override to read clearly<br>    virtual void BeginPlay() override;<br>};</p>
<p>int main()<br>{<br>    Object* obj &#x3D; new Object;<br>    obj-&gt;BeginPlay();</p>
<pre><code>Actor* act = new Actor;
act-&gt;BeginPlay();

delete obj;
delete act;

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>void Object::BeginPlay()<br>{<br>    cout &lt;&lt; “Object BeginPlay has been called\n”;</p>
<p>}</p>
<p>void Actor::BeginPlay()<br>{<br>    cout &lt;&lt; “Actor BeginPlay has been called\n”;<br>    Object::BeginPlay();<br>}</p>
<p>十九、多态<br>1.<br>2.<br>3.实例<br>①<br>#include<iostream><br>using namespace std;</p>
<p>class Object<br>{<br>public:<br>    virtual void BeginPlay();<br>};</p>
<p>class Actor:public Object<br>{<br>public:<br>    virtual void BeginPlay() override;<br>};</p>
<p>int main()<br>{<br>    Object* prt_to_object &#x3D; new Object;<br>    Actor* prt_to_actor &#x3D; new Actor;</p>
<pre><code>Object* ObjectArray[] = &#123;prt_to_object,prt_to_actor&#125;;

for (int i = 0;i &lt; 2;i++)
&#123;
    ObjectArray[i]-&gt;BeginPlay();
&#125;

delete prt_to_object;
delete prt_to_actor;

system(&quot;pause&quot;);
</code></pre>
<p>}</p>
<p>void Object::BeginPlay()<br>{<br>    cout &lt;&lt; “Object BeginPlay() called.\n”;<br>}</p>
<p>void Actor::BeginPlay()<br>{<br>    cout &lt;&lt; “Actor BeginPlay() called.\n”;<br>}</p>
<p>二十、多继承<br>1.虚继承：当派生链中的子类包含同名函数的两个版本，想要正确调用某个版本时可以使用虚继承，即无论虚继承的同名函数有多少只调用一个副本。若（基）父类p的（派生类）子类a和b都有函数f()，且a和b共同的子类c的同名函数同时虚继承自a和b，那么调用c的同名函数时就相当于是取得p中函数f()的指针。（菱形继承问题）<br>2.上述子类a和b可以重写，但要完全限定名称以调用。<br>3.最后有争论，通过实践得出虚继承是可以进行虚函数操作，但只能A和B中只有一个可以进行虚函数操作<br>4.上述菱形继承中，可以说子类a，b，c和p是is-A关系，即a，b，c相当于p，但除了c能和p相互直接转换值，其余都不能说p相当于a或者b，类型无法确定，自然无法从p向下转型，此时需要用到动态转换。</p>
<p>二十一、转换<br>1.直接转型、向下转型与交叉转型</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://weblog51.top">Gachi51</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://weblog51.top/2024/05/20/c++_tutorials/">http://weblog51.top/2024/05/20/c++_tutorials/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://weblog51.top" target="_blank">我亦博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/weblog51.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/05/14/hello-world/" title="旅途伊始"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">旅途伊始</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/weblog51.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Gachi51</div><div class="author-info__description">欢迎(*｀▽´*)ノ亻!<br/>一名普通的计算机学生<br>希望与有趣的灵魂产生碰撞与共鸣</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Gunndzi/Gunndzi.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%AC%94%E8%AE%B0-%E5%B0%9A%E6%9C%AA%E6%95%B4%E7%90%86%E5%AE%8C%E6%AF%95"><span class="toc-number">1.</span> <span class="toc-text">C++笔记(尚未整理完毕)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.1.</span> <span class="toc-text">小建议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-%E9%92%88%E5%AF%B9Windows%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.</span> <span class="toc-text">准备工作 | 针对Windows系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87"><span class="toc-number">1.3.1.</span> <span class="toc-text">设备:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-IDE"><span class="toc-number">1.3.2.</span> <span class="toc-text">开发环境(IDE):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83-RE"><span class="toc-number">1.3.3.</span> <span class="toc-text">运行环境(RE):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.3.4.</span> <span class="toc-text">新建项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E9%A1%B5%E9%9D%A2"><span class="toc-number">1.3.5.</span> <span class="toc-text">新建页面</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA%E6%96%87%E6%9C%AC-Hello-World"><span class="toc-number">1.4.</span> <span class="toc-text">一、打印输出文本 Hello World!</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/20/c++_tutorials/" title="C++笔记">C++笔记</a><time datetime="2024-05-20T09:33:32.000Z" title="发表于 2024-05-20 17:33:32">2024-05-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/14/hello-world/" title="旅途伊始">旅途伊始</a><time datetime="2024-05-14T09:18:26.655Z" title="发表于 2024-05-14 17:18:26">2024-05-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Gachi51</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>